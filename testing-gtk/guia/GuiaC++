------------
- GUIA C++ -
------------

2.1 DECLARACION DE VARIABLES
{
- Declaracion de variables
Para declarar variables se usa la siguiente sintaxis:

	type varName;

Aqui, 5 diferentes variables de 5 diferentes tipos:

	bool bValue;
	char chValue;
	int nValue;
	float fValue;
	double dValue;

  + Asignamiento explicito
	Usamos el operador igual (=)
	
	int nValue = 5;

  + Asignamiento implicito

	int nValue(5); 
	Yep, parece una funcion, pero resulta que C++ lo identifica y bueno, el valor se
	asigna a la variable.

- Declaracion de multiples variables
Es posible declarar multiples varaibles del mismo tipo en una sola linea separando los nombres
con una coma

	int nValue1, nValue2;
	// que seria lo mismo que
	int nValue1;
	int nValue2;

Tambien podemos asignar valores

	int nValue1 = 5, nValue = 6;
	int nValue3(7), nValue4(8);

Evitar errores como:
	int nValue1, int nValue2;
	int nValue1, double nValue2;
	int nValue1, nValue = 5; // @DUDAKEN Probaste en serio este error? D::::
													 //	@Diego Pues, no... pero de acuerdo con la pagina, si existen errores. Tu no has tenido ese error antes? D:

- Cuando declararlas?
Cuando quieras, es lo bueno de C++. En C, por ejemplo, debes declara las variables en la parte
de arriba del programa. En C++ no importa donde lo hagas.
}

2.2 PALABRAS CLAVE E INDENTIFICACION POR NOMBRE
{
- Palabras Clave
Hay 63 palabras clave que no debes usar, ya que son exclusivas de C++
asm			auto 		bool * 		break	case	catch	char	class 	const	const_cast *
continue	default		delete		do		double	dynamic_cast * 	else	enum	explicit *
export *	extern		false *		float	for 	friend	goto	if		inline	int
long		mutable *	namespace * new		operator		private	protected		public
register	reinterpret_cast *		return 	short	signed	sizeof	static	static_cast *	struct
switch		template 	this		throw	true *	try		typedef	typeid *		typename *
union 		unsigned	using *		virtual	void	volatile		wchar_t *		while 

- Identificadores y como nombrarlos
El nombre de una variable, una funcion, clase o cualquier otra entidad en C++ se llama
identificador. Puedes llamarlo como quieras, pero existen algunas reglas:
	1. El nombre no puede ser una palabra clave
	2. Puede solo estar compuesta de letras, numeros y el guion bajo (_). No puede
	tener simbolos o espacios.
	3. Debe comenzar con una letra minuscula o un guion bajo. No puede comenzar con un numero
	4. C++ distingue entre minusculas y mayusculas(Case Sensitive).

2.3 EL OPERADOR sizeof()
Para determinar el tamaño de un tipo de variable en una compuadora en particular, C++ provee
el operador sizeof. Regresa en bytes el tamano del tipo, esto varia en distintas
computadoras.

Ej:
=CODEAHEAD=
#include <iostream>

int main()
{
	using namespace std;
	cout << "bool:\t\t" << sizeof(bool) << " bytes" << endl;
	cout << "char:\t\t" << sizeof(char) << " bytes" << endl;
	cout << "wchar_t:\t" << sizeof(wchar_t) << " bytes" << endl;
	cout << "short:\t\t" << sizeof(short) << " bytes" << endl;
	cout << "int:\t\t" << sizeof(int) << " bytes" << endl;
	cout << "long:\t\t" << sizeof(long) << " bytes" << endl;
	cout << "float:\t\t" << sizeof(float) << " bytes" << endl;
	cout << "double:\t\t" << sizeof(double) << " bytes" << endl;
	cout << "long double:\t" << sizeof(long double) << " bytes" << endl;
	return 0;
}
=ENDCODE=

@Diego Recuerda que este resultado es solo para la computadora de quien lo compilo y ejecuto ya que varia dependiendo de la pc compiladora.

=RESULTS=
bool:		1 bytes
char:		1 bytes
wchar_t:	4 bytes
short:		2 bytes
int:		4 bytes
long:		8 bytes
float:		4 bytes
double:		8 bytes
long double:	16 bytes
=ENDRSTS=

}

2.4 ENTEROS
{
Un entero es un tipo de variable que puede tener numeros enteros xd
C++ tiene 4 tipos: char, short, int y long. La diferencia entre ellos  es que
varian en tamano. Uno puede almacenar un numero mucho mas grande que el otro.
otra vez, depende de la computadora.

Declaramos alguno de la forma:
char chChar;
short int nShort; 	// 'short int' es tecnicamente correcto
short nShort;		// quizas es mas preferido
int nInteger;
long int nLong;		// asi como el short int
long nLong;			// preferido

- Variables 'firmadas' (signed) y 'no firmadas' (unsigned)
Una variable 'firmada' es una que puede almacenar tanto negativos como positivos.
Para declarar una variable firmada se usa la palabra 'signed'
signed char chChar;
signed short nShort;
signed int nInt;
signed long nLong;

Si sabemos que no necesitaremos negativos, entonces usamos unsigned ( Esto dobla la cantida máxima que podríamos usar )
unsigned char chChar;
unsigned short nShort;
unsigned int nInt;
unsigned long nLong;

Predeterminadamente, todas las variables declaras sin signed/unsigned son 'signed'.

# Nota del traductor: tal parece que signed viene de signo (+/-) mas que de firma xd

Entonces, aqui una tablita con los rangos:
Tamano y tipo		Rango
1 byte signed		-128 a 127
1 byte unsigned		0 a 255
2 byte signed		-32,768 a 32,767
2 byte unsigned		0 a 65,535
4 byte signed		-2,147,483,648 a 2,147,483,647
4 byte unsigned		0 a 4,294,967,296
8 byte signed		-9,223,372,036,854,775,807 a 9,223,372,036,854,775,807
8 byte unsigned		0 a 18,446,744,073,709,551,615

Para una variable 'signed' de n-bits tiene el rango de  -(2^(n-1)) a (2^(n-1))-1.
Para una variable 'unsigned' de n-bits tiene el rango de 0 a (2^n)-1

- Overflow
Cuando sobrepasas un tipo de variable.

=CODEAHEAD=
#include <iostream>
 
int main()
{
    using namespace std;
    unsigned short x = 65535; // largest 2-byte unsigned value possible
    cout << "x was: " << x << endl;
    x = x + 1; // We desire 65536, but we get overflow!
    cout << "x is now: " << x << endl;
}
=ENDCODE=
=RESULTS=
x was: 65535
x is now: 0
=ENDRSTS=

Es como que si sobrepasa, entonces regresa al inicio. Sucede algo parecido cuando es
viceversa.
}

2.5 FLOATING POINTS
{
A veces necesitamos contar con números más grandes que los tipo int pueden soportar, otras veces necesitamos números reales como 2.35 , 0.58327 ,etc  . Para esto estan los números de punto flotante, existen tres tipos:
	-float  //4 bytes
	-double //8 bytes 
	-long double //16 bytes
	
Como conveción se pone un decimal al menos para diferenciar de los otros al declarar variables:

	int nValue = 5; // 5 means integer
	float fValue = 5.0; // 5.0 means floating point

Siéntete todo un crack declarando variables de punto flotante de modo científico:

	double dValue1 = 500.0;
	double dValue2 = 5e2; // another way to assign 500
	 
	double dValue3 = 0.05;
	double dValue4 = 5e-2; // another way to assign 0.05

Se puede determinar la precisión para cuando trabajemos con estas variables. La precisión predeterminada son 6 dígitos.

=CODEAHEAD=
	#include <iostream>
	#include <iomanip> // for setprecision()
	int main()
	{
    using namespace std;
 
    cout << setprecision(16); // show 16 digits
    float fValue = 3.33333333333333333333333333333333333333f;
    cout << fValue << endl;
    double dValue = 3.3333333333333333333333333333333333333;
    cout << dValue << endl;	

	}
=ENDCODE=

=RESULTS=
	3.333333253860474 // como se puede ver, se pierde mucha precisión con float (a lo más se trabaja con 7 dígitos)
	3.333333333333334 // double dobla la precisión de dígitos con los que se puede trabajar D:
=ENDRESULTS=

Los inconvenientes con este tipo de variables es que tiene muchos problemas de precisión, se debe tener cuidado cuando se compara números que son muy cercanos. Ejemplo.

=CODEAHEAD=
	float fValue1 = 1.345f;
	float fValue2 = 1.123f;
	float fTotal = fValue1 + fValue2; // should be 2.468
	 
	 if (fTotal == 2.468)
	     cout << "fTotal is 2.468";
	 else
			 cout << "fTotal is not 2.468";
=ENDCODE=

=RESULTS=
fTotal is not 2.468
=ENDOCODE= 

Error típico por el rounding error que básicamente es cómo se guarda la variable que en este caso tiene el valor de 2.4679999 que no es 2.468. ¡TENER CUIDADO AL COMPARAR CON PUNTO FLOTANTE!

2.6 BOOLEANOS
{
Los booleanos pueden ser verdadero (1) o falso (0).
Para declararlos, pues, es:
	bool bValue;
	bool bValue1 = true; // forma explicita
	bool bValue2(false); // forma implicita

Tambien se puede, asi como usar el menos para los enteros/flotantes/etc, se puede usar el operador NOT para cambiar de V a F y de F a V.
	bool bValue1 = !true;
	bool bValue2(!false);

Los booleanos son evaluados en numeros, no como 'true' o 'false'

=CODEAHEAD=
	bool bValue = true;
	cout << bValue << endl;
	cout << !bValue << endl;
=ENDCODE=

=RESULTS=
	1
	0
=ENDRSLT=

Tambien se puede usar de la forma:
=CODEAHEAD=
	bool bValue = true;
	if (bValue)
		cout << 'bValue es verdadero' << endl;

	bool bValue2 = true;
	if (!bValue2)
		cout << 'el if fue verdadero' << endl;
	else
		cout << 'el if fue falso' << endl;

=ENDCODE=
=RESULTS=
	bValue es verdadero
	el if fue falso
=ENDRSLT=

Una ultima forma de usarlo es dandolo como resultado de una funcion:

=CODEAHEAD=
	bool IsEqual(int x, int y)
	{
		return (x == y);
	}

	int main()
	{
		// se pide valores de 'x' y 'y'
		// -- primera forma de hacerlo:
		bool bEqual = IsEqual(x, y);
		if (bEqual)
			cout << x << ' y ' << y << ' son iguales' << endl;
		else
			// lo contrario

		// -- segunda forma de hacerlo
		if (IsEqual(x, y))
			// Y bueno, aqui si fue/resulto verdadero
	}
=ENDCODE=

}

2.7 CHARS
{
	Mira esto es sencillo, los chars son en realidad integers disfrazados D: guíados por ASCII.
	Ejemplo, el caracter 'a' está asociado con 97 ( para el teclado inglés ).Entonces si tenemos:

=CODEHEAD=
	char chChar = 97; // assign char with ASCII code 97
	cout << chChar; // will output 'a'

	char chChar = 97;
	cout << (int)chChar; // will output 97, not 'a'
	// a esto de (int) se le llama MÁSCARA(casting en inglés), que es una forma que "disfrazar" otra vez. Osea, un integer disfrazado de char que está disfrazado de integer xD:
=ENDCODE=

Con esta info puedes hacerte un programa para sacar el número asociado a cada caracter D: pero para ahorrarte la molestia...

=CODEHEAD=
#include "iostream";
 
 int main()
 {
     using namespace std;
		 char chChar;
		 cout << "Input a keyboard character: ";
		 cin >> chChar; // cCHar solo tomará el primer caracter que escribas.
		 cout << chChar << " has ASCII code " << (int)chChar << endl;
 }
=ENDCODE= 

Muyayo ten cuidado, que cuando declaras chars, tienes que hacerlo con ' ' . Aclaración:

	char chValue = '5'; // assigns 53 (ASCII code for '5')
	char chValue2 = 5; // assigns 5

Habrás notado que, a veces para hacer salto de línea haces '\n', bueno esto es llamado escape sequence. Aquí otras muy usadas.

	\t - tab
	\' - imprime un ' 
	\" - imprime un "
	\\ - imprime un \
	\r - retorna a la primera parte de la linea
	\v - vertical tab D: esto no me lo sabía

}

2.8 CONSTANTES
{
	En C++ hay dos tipo de constantes: literales y simbolicos.
	- Constantes literales
		Las constantes literales son los numeros insertados directamente en el codigo. No cambian su valor, por eso son constantes.

		int x = 5;

		Estos numeros pueden tener sufijos para determinar su tipo. Tales como u/U para determinar si son unsigned o l/L para determinar si son Long.
		pero es opcional, ya que el compilador mayormente lo encuentra.

		unsigned int nValue = 5u; 	// constante sin-signo
		long nValue2 = 5L; 					// constante en Long

		Generalmente no es buena idea hacer constantes literales que no sean 0 o 1. Luego se vera por que (numeros magicos, dice) 

	- Constantes Simbolicas
		Usando el #define puedes crear 'variables' que son ser cambiadas antes de compilar
		
		#define PEN_PER_USD 2.58
		float nPen = nDollars * PEN_PER_USD;

		El problema con esto es que nunca podras ver el #define al momento de buscar errores con el debugger. Luego, si tu codigo es largaso
		y quieres saber que es PEN_PER_USD tendrias que ir a las primeras lineas de tu codigo. (Si muchacho, deben estar al principio del codigo).
		Otra cosa es que son variables globales y pueden tener comflictos si tienes el mismo nombre para esa variable en otro pedazo de codigo.

		Existe otra forma de crear constantes:

		const float nPenPerUsd = 2.58;
		float nPen = nDollars * nPenPerUsd;

		Ese nPenPerUsd no podra ser modificado nunca en la vida.
		const int nRandom = 14534;
		nRandom = 123; // Error de compilador.

		Resulta que estos numeros constantes pueden ser bastante buena ayuda. Hay algunos que usan todo en mayusculas (como el ejemplo de PEN_PER_USD)
		pero si nos quedamos en la notacion hugariana sera mejor ya que no tendremos que lidiar mucho con los nombres

}

2.9 NOTACION HUNGARIANA (?)
{
	// Mosuc
}

3.1 PRECEDENCIA Y ASOCIATIVIDAD
{
	// Precedencia y asociatividad
}

3.2 OPERADORES ARITMETICOS
{
	// operadores aritmeticos
}

3.3 OPERADORES DE INCREMENTACION/DECREMENTACION (?) Y EFECTOS SECUNDARIOS
{
	// ++ --
}

3.4 sizeof, comma y operadores aritmeticos con 'if'
{
	// if ()...
}

3.5 COMPARADORES
{
}

3.6 OPERADORES LOGICOS
{
}

3.7 CONVERSION ENTRE BINARIOS Y DECIMALES
{
}

3.8 OPERADORES NIVEL-BIT
{
}

4.1 BLOCKS Y VARIABLES LOCALES
{
}

4.2 VARIABLES GLOBALES
{
}

4.3 ALCANCE DE ARCHIVOS Y LA PALABRA CLAVE static
{
}

4.4 CONVERSION DE TIPOS Y CASTING
{
}

4.5 TIPOS ENUMERADOS
{
}

4.6 TYPEDEFS
{
}

4.7 STRUCS
{
}









